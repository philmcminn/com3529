\input{common/setup}

\begin{document}

\title{Automatic Test Case Generation}{5.1 Symbolic Execution}

\section{Introduction --- Static and Dynamic Analysis}

Software Testing usually takes the form of what's known as {\it dynamic
Analysis} activity. {\it Dynamic} simply means that we {\it execute} the program
under test to test it. You may think this distinction is crazy --- how could we
test a program without running it? 

Well, there exist a number of techniques that are capable of performing {\it
Static Analysis} of a program. This means they take the program code (or some
model of it), and scrutinise properties of it using theorem provers or
constraint solvers. This can help us find interesting issues with our software,
such as deadlocks, or infeasible paths. While Dynamic Analysis involves
executing software one input at a time (and the overheads that brings for any
program of a reasonable size --- as we saw in the introductory material to this
module), techniques based on Static Analysis are capable of reasoning about
multiple sets of inputs at once. Static Analysis can also be used to derive
interesting test cases automatically. Symbolic Execution is one technique that
can do this.

\section{Symbolic Execution}

Symbolic Execution does not involve actually executing a program for real.
Instead, Symbolic Execution works through a program, building up a series of
equations over its inputs, one for each program path, known as {\it path
conditions}. A path condition for a particular path describes the set of inputs
that will execute it.

Whereas a typical program test only explores one particular program execution
--- where we {\it hope} the test case generates (but of course, there are no
guarantees of this) --- the aim of Symbolic Execution is to build an abstraction
over {\it all} possible program executions, on a path-by-path basis.

Hopefully, you'll have already spotted a potential drawback to Symbolic
Execution already --- in general it is not possible to explore {\it every}
program path, because in general, there may be an infinite number of program
paths. Let's suspend that thought for a moment --- we'll come back to this issue.

\subsection{Worked Example}

To understand how Symbolic Execution works, let's visualise a program as a
binary tree (with possibly infinite depth). This is called the {\it computation
tree}. A computation tree can be formed from the nodes of a CFG. Each series of
nodes from the root of the tree to a leaf is a path through the CFG/program.

Here is the computation tree for the \classifymethod~method of the
\triangleclass~class, for example:

%

Symbolic Execution works through the computation tree starting at the root node,
beginning with an empty path condition that the technique builds up as it moves
down the computation tree. While this is happening, the technique simultaneously
maintains the {\it symbolic state} of each input variable. To begin with, at the
root node of the computation tree, and instead of being assigned a value, each
input variable is instead assigned to a symbol. 

A {\it depth-first} exploration of the computation tree then works at follows.
Proceeding down the tree, Symbolic Execution invokes a constraint solver at each
branching point, to see if the branches is feasible. If a branch is not
feasible, it ignores it. If one branch is feasible it takes the branch, if both
branches are feasible, it takes one of the branches, leaving the other on a
stack to return to when the exploration of the current path has completed. 

In our worked example, we're going to explore the left-most path of the
computation tree where each branch predicate is true. A Symbolic Execution of
this particular path works as follows:

\begin{center}
\scalebox{0.85}{
\begin{tabular}{rllllll}
\toprule 
CFG         &                                                  & \multicolumn{4}{c}{Symbolic State}      & \\
\cline{3-6}              
Node        & Code                                             & {\tt side1} & {\tt side2} & {\tt side3} & {\tt temp} & Path Condition  \\
\midrule          
s           &                                                  & $\alpha$    & $\beta$     & $\gamma$    & -          & $\mathit{true}$  \\
            & {\tt if (side1 > side2)} {\it as TRUE}           & $\alpha$    & $\beta$     & $\gamma$    & $\alpha$   & $\alpha > \beta$ \\
            & {\tt int temp = side1}                           & $\alpha$    & $\beta$     & $\gamma$    & $\alpha$   & $\alpha > \beta$ \\
            & {\tt side1 = side2}                              & $\beta$     & $\beta$     & $\gamma$    & $\alpha$   & $\alpha > \beta$ \\
            & {\tt side2 = temp}                               & $\beta$     & $\alpha$    & $\gamma$    & $\alpha$   & $\alpha > \beta$ \\
            & {\tt if (side1 > side3)} {\it as TRUE}           & $\beta$     & $\alpha$    & $\gamma$    & -          & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt int temp = side1}                           & $\beta$     & $\alpha$    & $\gamma$    & $\beta$    & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt side1 = side3}                              & $\gamma$    & $\alpha$    & $\gamma$    & $\beta$    & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt side3 = temp}                               & $\gamma$    & $\alpha$    & $\beta$     & $\beta$    & $\alpha > \beta \wedge \beta > \gamma$ \\            
            & {\tt if (side2 > side3)} {\it as TRUE}           & $\gamma$    & $\alpha$    & $\beta$     & -          & $\alpha > \beta \wedge \beta > \gamma$ {\scriptsize (no change)}\\    
            & {\tt int temp = side2}                           & $\gamma$    & $\alpha$    & $\beta$     & $\alpha$   & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt side2 = side3}                              & $\gamma$    & $\beta$     & $\beta$     & $\alpha$   & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt side3 = temp}                               & $\gamma$    & $\beta$     & $\alpha$    & $\alpha$   & $\alpha > \beta \wedge \beta > \gamma$ \\
            & {\tt if (side1 + side2 <= side3)} {\it as TRUE}  & $\gamma$    & $\beta$     & $\alpha$    & $\alpha$   & $\alpha > \beta \wedge \beta > \gamma \wedge \gamma + \beta \leq \alpha$ \\
\bottomrule
\end{tabular}}
\end{center}

To begin with, the three inputs are assigned to symbols. As such {\tt side 1}$ =
\alpha$, {\tt side2}$ = \beta$, and {\tt side3}$ = \gamma$, respectively. There
is also another variable in the program, {\tt temp}, that we need to account
for. This variable appears in the body of each of the {\tt if} statements, and
then goes out of scope. 

The first branch predicate Symbolic Execution finds is {\tt side1 > side2}. To
execute this as {\it true}, the path condition is updated to $\alpha > \beta$.
The body of the {\tt if} statement updates the symbolic state of the inputs. The
variables {\tt side1} and {\tt side2} are swapped, so {\tt side1} becomes equal
to $\beta$ while {\tt side2} becomes equal to $\alpha$. 

The second branch predicate encountered is {\tt side1 > side3}. To take the true
branch, the path condition now needs to be updated with this predicate, but
substituted with the current symbolic states of {\tt side1} and {\tt side3},
that is, $\beta > \gamma$. The path condition now becomes $\alpha > \beta \wedge
\beta > \gamma$. In the body of this {\tt if} statement, {\tt side1} and {\tt
side3} are swapped, so their symbolic states are updated --- {\tt side1} now
becomes equal to $\gamma$, while {\tt side3} becomes $\beta$.

The third branch predicate encountered is {\tt side2 > side3}. Taking the true
branch would result in $\alpha > \beta$ being appended to the path condition.
However this already appears in the path condition as a conjunct. Since $\alpha
> \beta \wedge \beta > \gamma$ is equivalent to $\alpha > \beta \wedge \beta >
\gamma \wedge \alpha > \beta$, the path condition does not change in practice.
In the body of the {\tt if} condition, {\tt side2} becomes equal to $\beta$
again, while {\tt side3} becomes equal to $\alpha$.

The fourth and final branch predicate is {\tt side1 + side2 <= side3}.
Substituting again for the current symbolic states of the three variables, 
executing this predicate as true requires $\gamma + \beta \leq \alpha$ to be
added to the path condition. 

The program then terminates after executing the body of this {\tt if} statement.
(Since there are no more branching predicates to execute, we stop tracking the
symbolic states of the program's variables at this point.) We now have a
complete path condition that can be re-written in terms of the original inputs.
We do this by subsituting the symbols by the original input variables they
originally represented, by performing the reverse of the first step. That is, As
such $\alpha = ${\tt side 1}, $\beta = ${\tt side2}, and $\gamma = ${\tt side3}.

\begin{center}
{\tt side1}~$ > $~{\tt side2}~$ \wedge $~{\tt side2}~$ > $~{\tt side3}~$ \wedge
$~{\tt side3}~$ + $~{\tt side2}~$ \leq $~{\tt side1}
\end{center}

This equation represents the inputs that will take this particular path. We can
now give this to a constraint solver, such as Z3, which can provide us with an
example of a real input, e.g. {\tt side1}$ =
3$, {\tt side2}$ = 2$, and {\tt side3}$ = 1$.

\subsection{Drawbacks}

Because of the exponential explosion in paths, it's clear that Symbolic
Execution will not scale for large programs. Another problem for Symbolic
Execution is that constraint solvers are not always powerful enough to find
inputs that satisfy the path constraints. Constraint solvers have historically
found non-linear equations difficult to reason about (some have even applied
optimisation techniques like Gradient Descent to try to circumvent these
issues). Further problems are inherent when a program takes a dynamic data
structure as an input (e.g., a map, tree, or a list) that are not fixed in terms
of shape and size. 

In situations like this, researchers like to try to combine two different
approaches in order to get the benefits of both without suffering the
limitations of either. This led to a new technique {\it Dynamic Symbolic
Execution}, which combines the concrete execution of Random Testing with
Symbolic Execution.

\section{Dynamic Symbolic Execution}

Dynamic Symbolic Execution, sometimes called {\it Concolic Execution} (for {\it
Conc}rete Symb{\it olic} Execution),

\end{document}